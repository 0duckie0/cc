/*
  * exp_postfix.y - YACC Grammar for Postfix Expression Evaluation
  *
  * Note: The YYSTYPE is implicitly int as required by the yylval in the Lex file.
*/
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function declaration for the lexical analyzer
int yylex(void);
// Function declaration for error reporting
void yyerror(char *s);

// Global stack for evaluation
int stack[100];
int top = -1;

// Stack operations
void push(int val);
int pop();

// Function to perform arithmetic operations
int calculate(int op, int s1, int s2);
%}

// Token Definitions (from Lex)
%token NUMBER

// Grammar Rules (Precedence/Associativity are not strictly needed for basic postfix)
%start program

%%
// Grammar Section

program:
      /* empty */
    | program expression '\n' {
        // After successfully parsing an expression followed by a newline
        printf("\nResult: %d\n\n", $2); // $2 is the result of the expression
        top = -1; // Reset stack for the next expression
      }
    ;

expression:
      NUMBER         { $$ = $1; push($1); } // Push number onto the stack, $$ = value
    | expression expression '+' {
        int s2 = pop();
        int s1 = pop();
        $$ = calculate('+', s1, s2);
        push($$); // Push result back onto the stack
      }
    | expression expression '-' {
        int s2 = pop();
        int s1 = pop();
        $$ = calculate('-', s1, s2);
        push($$);
      }
    | expression expression '*' {
        int s2 = pop();
        int s1 = pop();
        $$ = calculate('*', s1, s2);
        push($$);
      }
    | expression expression '/' {
        int s2 = pop();
        int s1 = pop();
        $$ = calculate('/', s1, s2);
        push($$);
      }
    ;

%%

// User Subroutines Section

// YACC Error function
void yyerror(char *s) {
    fprintf(stderr, "Error: %s\n", s);
    fprintf(stderr, "Check your expression syntax (Polish Notation).\n");
}

// Stack helper functions
void push(int val) {
    if (top < 99) {
        stack[++top] = val;
    } else {
        fprintf(stderr, "Stack overflow!\n");
    }
}

int pop() {
    if (top >= 0) {
        return stack[top--];
    } else {
        fprintf(stderr, "Stack underflow (Missing operand)!\n");
        return 0;
    }
}

// Calculation function
int calculate(int op, int s1, int s2) {
    switch(op) {
        case '+': return s1 + s2;
        case '-': return s1 - s2;
        case '*': return s1 * s2;
        case '/': 
                  if (s2 == 0) {
                      fprintf(stderr, "Error: Division by zero!\n");
                      return 0;
                  }
                  return s1 / s2;
        default: return 0;
    }
}

int main(void) {
    printf("Postfix Expression Evaluator (Reverse Polish Notation)\n");
    printf("Enter expression (e.g., 5 2 + 10 *):\n");
    printf("Press Ctrl+D to stop.\n\n");

    // Start parsing
    yyparse();

    return 0;
}


//Save Files: Save the Lex code as exp_postfix.l and the YACC code as exp_postfix.y.
YACC Compilation: Use yacc (or bison) to generate the C parser code (y.tab.c) and the header file (y.tab.h): yacc -d exp_postfix.y 
Lex Compilation: Use flex to generate the C lexical analyzer code (lex.yy.c): flex exp_postfix.l
Final Compilation: Compile all generated C files together, linking the necessary libraries: gcc lex.yy.c y.tab.c -ll -o postfix_eval
Execution: Run the executable: ./postfix_eval

